=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/maindart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'app/router.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      routerConfig: appRouter,
      theme: ThemeData(
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          titleTextStyle: TextStyle(color: Colors.black, fontSize: 20),
          iconTheme: IconThemeData(color: Colors.black),
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/app/routerdart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../features/language/screens/language_select_screen.dart';
import '../features/profile_setup/screens/profile_setup_screen.dart';
import '../features/song_view/screens/song_view_screen.dart';
import '../features/song_view/screens/song_settings_screen.dart';
import '../features/song_view/screens/song_edit_screen.dart';
import '../features/song_view/screens/song_search_screen.dart';

final GoRouter appRouter = GoRouter(
  initialLocation: '/language',
  routes: [
    GoRoute(
      path: '/language',
      builder: (context, state) => const LanguageSelectScreen(),
    ),
    GoRoute(
      path: '/profile',
      builder: (context, state) => const ProfileSetupScreen(),
    ),
    GoRoute(
      path: '/song-view',
      builder: (context, state) => const SongViewScreen(),
    ),
    GoRoute(
      path: '/song-settings',
      builder: (context, state) => const SongSettingsScreen(
        textFontSize: 18,
        chordFontSize: 20,
        textColor: Colors.black,
        chordColor: Colors.blue,
        scrollUp: 3,
        scrollDown: 5,
      ),
    ),
    GoRoute(
      path: '/song-edit',
      builder: (context, state) => const SongEditScreen(filePath: ''),
    ),
    GoRoute(
      path: '/song-search',
      builder: (context, state) => const SongSearchScreen(),
    ),
  ],
);



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/common/services/profile_storage_servicedart ===
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';

class ProfileStorageService {
  static Future<String> _getProfilesFilePath() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/profiles.json');
    return file.path;
  }

  static Future<void> saveProfile({
    required String name,
    required String lyricsPath,
    required String attachmentsPath,
  }) async {
    final path = await _getProfilesFilePath();
    final file = File(path);
    List<Map<String, dynamic>> profiles = [];

    if (await file.exists()) {
      final content = await file.readAsString();
      profiles = List<Map<String, dynamic>>.from(json.decode(content));
    }

    profiles.removeWhere((p) => p['name'] == name);
    profiles.add({
      'name': name,
      'lyricsPath': lyricsPath,
      'attachmentsPath': attachmentsPath,
    });

    await file.writeAsString(json.encode(profiles));
  }

  static Future<List<Map<String, dynamic>>> loadProfiles() async {
    final path = await _getProfilesFilePath();
    final file = File(path);
    if (!await file.exists()) return [];
    final content = await file.readAsString();
    return List<Map<String, dynamic>>.from(json.decode(content));
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/common/utils/file_utilsdart ===
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

class FileUtils {
  static Future<Directory> getInternalDirectory() async {
    return await getApplicationDocumentsDirectory();
  }

  static Future<File> getInternalFile(String fileName) async {
    final dir = await getInternalDirectory();
    return File(p.join(dir.path, fileName));
  }

  static Future<Directory> getSetlistDirectory() async {
    final dir = await getInternalDirectory();
    final setlistDir = Directory(p.join(dir.path, 'setlists'));
    if (!setlistDir.existsSync()) {
      setlistDir.createSync(recursive: true);
    }
    return setlistDir;
  }

  static Future<void> copyTxtFilesToInternal(String sourceFolderPath) async {
    final sourceDir = Directory(sourceFolderPath);
    if (!sourceDir.existsSync()) return;

    final targetDir = await getInternalDirectory();

    final txtFiles = sourceDir
        .listSync()
        .whereType<File>()
        .where((f) => f.path.toLowerCase().endsWith('.txt'));

    for (final file in txtFiles) {
      final fileName = p.basename(file.path);
      final newPath = p.join(targetDir.path, fileName);
      final newFile = File(newPath);

      if (!newFile.existsSync()) {
        await file.copy(newPath);
      }
    }
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/internal_file/screens/internal_file_list_screendart ===
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:chordsbandkompok/features/internal_file/utils/song_loader.dart';

class InternalFileListScreen extends StatefulWidget {
  const InternalFileListScreen({super.key});

  @override
  State<InternalFileListScreen> createState() => _InternalFileListScreenState();
}

class _InternalFileListScreenState extends State<InternalFileListScreen> {
  List<File> _txtFiles = [];

  @override
  void initState() {
    super.initState();
    _loadTxtFiles();
  }

  Future<void> _loadTxtFiles() async {
    final files = await SongLoader.loadTxtFiles();
    setState(() {
      _txtFiles = files;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Popis pjesama'),
      ),
      body: ListView.builder(
        itemCount: _txtFiles.length,
        itemBuilder: (context, index) {
          final fileName = _txtFiles[index].uri.pathSegments.last;
          return ListTile(
            title: Text(fileName),
            onTap: () {
              context.push('/song', extra: fileName);
            },
          );
        },
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/internal_file/utils/song_loaderdart ===
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import '../../profile_setup/controllers/active_profile_controller.dart';

class SongLoader {
  static Future<List<File>> loadTxtFiles() async {
    final profile = await ActiveProfileController.getActiveProfileData();
    if (profile == null) return [];

    final txtPath = profile['lyricsPath'];
    if (txtPath == null) return [];

    final txtDir = Directory(txtPath);
    if (!await txtDir.exists()) return [];

    final List<FileSystemEntity> allFiles = await txtDir.list().toList();
    return allFiles
        .whereType<File>()
        .where((file) => file.path.toLowerCase().endsWith('.txt'))
        .toList();
  }

  static Future<String> loadFromInternalPath(String path) async {
    final file = File(path);
    return await file.readAsString();
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/language/screens/language_select_screendart ===
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';

class LanguageSelectScreen extends StatelessWidget {
  const LanguageSelectScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => SystemNavigator.pop(),
        ),
        title: const Text('Odaberi jezik'),
        actions: [
          Padding(
            padding: EdgeInsets.symmetric(horizontal: 8.0),
            child: ElevatedButton(
              onPressed: () {
                context.go('/profile');
              },
              child: const Text('SETUP MAPA I VEZA'),
            ),
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              onPressed: () {},
              child: const Text('HRVATSKI'),
            ),
            const SizedBox(height: 12),
            ElevatedButton(
              onPressed: () {},
              child: const Text('ENGLISH'),
            ),
            const SizedBox(height: 40),
            IconButton(
              icon: const Icon(Icons.arrow_forward, size: 40),
              onPressed: () {},
            )
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile/screens/profile_selector_screendart ===
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import '../../../profile_setup/controllers/active_profile_controller.dart';
import '../../../profile_setup/screens/profile_setup_screen.dart';
import '../widgets/profile_buttons.dart';

class ProfileSelectorScreen extends StatefulWidget {
  const ProfileSelectorScreen({super.key});

  @override
  State<ProfileSelectorScreen> createState() => _ProfileSelectorScreenState();
}

class _ProfileSelectorScreenState extends State<ProfileSelectorScreen> {
  List<String> profiles = [];

  @override
  void initState() {
    super.initState();
    _loadProfiles();
  }

  Future<void> _loadProfiles() async {
    final baseDir = await getApplicationDocumentsDirectory();
    final profilesDir = Directory("${baseDir.path}/profiles");

    if (await profilesDir.exists()) {
      final dirs = profilesDir
          .listSync()
          .whereType<Directory>()
          .toList();
      final names = dirs
          .map((d) => d.path.split(Platform.pathSeparator).last)
          .toList();
      setState(() {
        profiles = names;
      });
    }
  }

  void _selectProfile(String name) async {
    await ActiveProfileController.setActiveProfile(name);
    if (mounted) {
      Navigator.push(
        context,
        MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
      );
    }
  }

  void _deleteProfile(String name) async {
    final baseDir = await getApplicationDocumentsDirectory();
    final target = Directory("${baseDir.path}/profiles/$name");

    if (await target.exists()) {
      await target.delete(recursive: true);
      _loadProfiles(); // refresh lista
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Odabir profila")),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            if (profiles.isNotEmpty)
              Expanded(
                child: ProfileButtons(
                  profiles: profiles,
                  onProfileSelected: _selectProfile,
                  onProfileDelete: _deleteProfile,
                ),
              ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
                );
              },
              child: const Text("Novi profil"),
            ),
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile/widgets/profile_buttonsdart ===
import 'package:flutter/material.dart';

class ProfileButtons extends StatelessWidget {
  final List<String> profiles;
  final Function(String) onProfileSelected;
  final Function(String) onProfileDelete;

  const ProfileButtons({
    Key? key,
    required this.profiles,
    required this.onProfileSelected,
    required this.onProfileDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView(
      children: profiles
          .expand((profile) => [
                // Prvo dugme: otvaranje profila
                ElevatedButton(
                  onPressed: () => onProfileSelected(profile),
                  child: Text(profile),
                ),
                // Drugo dugme: takoÄ‘er otvara isti profil (test)
                ElevatedButton(
                  onPressed: () => onProfileSelected(profile),
                  child: Text("Otvoriti: $profile"),
                ),
              ])
          .toList(),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_selector/screens/profile_selector_screendart ===
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import '../../../profile_setup/controllers/active_profile_controller.dart';
import '../../../profile_setup/screens/profile_setup_screen.dart';

class ProfileSelectorScreen extends StatefulWidget {
  const ProfileSelectorScreen({super.key});

  @override
  State<ProfileSelectorScreen> createState() => _ProfileSelectorScreenState();
}

class _ProfileSelectorScreenState extends State<ProfileSelectorScreen> {
  List<String> profiles = [];

  @override
  void initState() {
    super.initState();
    _loadProfiles();
  }

  Future<void> _loadProfiles() async {
    final baseDir = await getApplicationDocumentsDirectory();
    final profilesDir = Directory("${baseDir.path}/profiles");

    if (await profilesDir.exists()) {
      final dirs = profilesDir
          .listSync()
          .whereType<Directory>()
          .toList();
      final names = dirs
          .map((d) => d.path.split(Platform.pathSeparator).last)
          .toList();
      setState(() {
        profiles = names;
      });
    }
  }

  void _selectProfile(String name) async {
    await ActiveProfileController.setActiveProfile(name);
    if (mounted) {
      Navigator.push(
        context,
        MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
      );
    }
  }

  void _deleteProfile(String name) async {
    final baseDir = await getApplicationDocumentsDirectory();
    final target = Directory("${baseDir.path}/profiles/$name");

    if (await target.exists()) {
      await target.delete(recursive: true);
      _loadProfiles(); // refresh
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Odabir profila")),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            if (profiles.isNotEmpty)
              Expanded(
                child: ListView.builder(
                  itemCount: profiles.length,
                  itemBuilder: (context, index) {
                    final profile = profiles[index];
                    return Row(
                      children: [
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () => _selectProfile(profile),
                            child: Text(profile),
                          ),
                        ),
                        const SizedBox(width: 8),
                        IconButton(
                          onPressed: () => _deleteProfile(profile),
                          icon: const Icon(Icons.delete),
                          tooltip: 'ObriĹˇi profil',
                        ),
                      ],
                    );
                  },
                ),
              ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
                );
              },
              child: const Text("Novi profil"),
            ),
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/controllers/active_profile_controllerdart ===
import 'dart:io';
import 'dart:convert';
import 'package:path_provider/path_provider.dart';

class ActiveProfileController {
  static Future<File> _getActiveProfileFile() async {
    final dir = await getApplicationDocumentsDirectory();
    return File('${dir.path}/active_profile.txt');
  }

  static Future<void> setActiveProfile(String name) async {
    final file = await _getActiveProfileFile();
    await file.writeAsString(name);
  }

  static Future<String?> getActiveProfileName() async {
    final file = await _getActiveProfileFile();
    if (!await file.exists()) return null;
    return await file.readAsString();
  }

  static Future<Map<String, dynamic>?> getActiveProfileData() async {
    final dir = await getApplicationDocumentsDirectory();
    final profileFile = File('${dir.path}/profiles.json');
    if (!await profileFile.exists()) return null;

    final content = await profileFile.readAsString();
    final profiles = List<Map<String, dynamic>>.from(jsonDecode(content));

    final activeName = await getActiveProfileName();
    if (activeName == null) return null;

    return profiles.firstWhere(
      (p) => p['name'] == activeName,
      orElse: () => {},
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/controllers/current_profile_loaderdart ===
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';

class CurrentProfileLoader {
  static Future<Map<String, dynamic>?> loadLastProfile() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/profiles.json');
    if (!file.existsSync()) return null;

    final content = await file.readAsString();
    final profiles = List<Map<String, dynamic>>.from(jsonDecode(content));

    if (profiles.isEmpty) return null;
    return profiles.last;
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/controllers/profile_controllerdart ===
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';

class ProfileController {
  static Future<void> saveProfile({
    required String name,
    required String lyricsPath,
    required String mediaPath,
    required String connection,
  }) async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/profiles.json');

    List<Map<String, dynamic>> profiles = [];

    if (await file.exists()) {
      final content = await file.readAsString();
      final decoded = jsonDecode(content);
      profiles = List<Map<String, dynamic>>.from(decoded);
    }

    profiles.removeWhere((p) => p['name'] == name);

    profiles.add({
      'name': name,
      'lyricsPath': lyricsPath,
      'mediaPath': mediaPath,
      'connection': connection,
    });

    await file.writeAsString(jsonEncode(profiles));
  }

  static Future<List<Map<String, dynamic>>> loadProfiles() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/profiles.json');

    if (!await file.exists()) {
      return [];
    }

    final content = await file.readAsString();
    final decoded = jsonDecode(content);
    return List<Map<String, dynamic>>.from(decoded);
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/screens/profile_selector_screendart ===
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import '../../common/utils/file_utils.dart';
import '../controllers/active_profile_controller.dart';
import 'profile_setup_screen.dart';

class ProfileSelectorScreen extends StatefulWidget {
  const ProfileSelectorScreen({Key? key}) : super(key: key);

  @override
  State<ProfileSelectorScreen> createState() => _ProfileSelectorScreenState();
}

class _ProfileSelectorScreenState extends State<ProfileSelectorScreen> {
  List<String> profiles = [];

  @override
  void initState() {
    super.initState();
    _loadProfiles();
  }

  Future<void> _loadProfiles() async {
    final dir = await getApplicationDocumentsDirectory();
    final profilesDir = Directory('${dir.path}/profiles');

    if (await profilesDir.exists()) {
      final dirs = profilesDir
          .listSync()
          .whereType<Directory>()
          .map((d) => d.path.split(Platform.pathSeparator).last)
          .toList();
      setState(() {
        profiles = dirs;
      });
    }
  }

  void _navigateToProfileSetup() async {
    await Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
    );
    _loadProfiles();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Izbor profila')),
      body: Column(
        children: [
          ElevatedButton(
            onPressed: _navigateToProfileSetup,
            child: const Text('Dodaj novi profil'),
          ),
          const SizedBox(height: 16),
          Expanded(
            child: ListView.builder(
              itemCount: profiles.length,
              itemBuilder: (context, index) {
                final profileName = profiles[index];
                return Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                  child: Row(
                    children: [
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () async {
                            await ActiveProfileController.setActiveProfile(profileName);
                            Navigator.pushReplacement(
                              context,
                              MaterialPageRoute(builder: (_) => const ProfileSetupScreen()),
                            );
                          },
                          child: Text(profileName),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.delete),
                        onPressed: () {
                          // logika brisanja se dodaje kasnije
                        },
                      ),
                    ],
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/screens/profile_setup_screendart ===
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:file_selector/file_selector.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import 'dart:convert';

import '../controllers/profile_controller.dart';
import '../controllers/active_profile_controller.dart';

class ProfileSetupScreen extends StatefulWidget {
  const ProfileSetupScreen({super.key});

  @override
  State<ProfileSetupScreen> createState() => _ProfileSetupScreenState();
}

class _ProfileSetupScreenState extends State<ProfileSetupScreen> {
  final TextEditingController _nameController = TextEditingController();
  String? _selectedTextFolder;
  String? _selectedMediaFolder;
  String? _selectedConnection;

  List<Map<String, dynamic>> _profiles = [];
  Map<String, dynamic>? _selectedProfile;

  Future<void> _loadProfiles() async {
    final loaded = await ProfileController.loadProfiles();
    setState(() {
      _profiles = loaded;
    });
  }

  @override
  void initState() {
    super.initState();
    _loadProfiles();
  }

  Future<String?> _copyFolderToProfile(String? sourcePath, String profileName, String subfolderName, String fileExtension) async {
    if (sourcePath == null) return null;

    final appDir = await getApplicationDocumentsDirectory();
    final profilePath = '${appDir.path}/profiles/$profileName/$subfolderName';
    final profileDir = Directory(profilePath);

    if (!await profileDir.exists()) {
      await profileDir.create(recursive: true);
    }

    final sourceDir = Directory(sourcePath);
    final files = sourceDir
        .listSync()
        .whereType<File>()
        .where((f) => f.path.toLowerCase().endsWith(fileExtension))
        .toList();

    for (var file in files) {
      final fileName = file.uri.pathSegments.last;
      final newFile = File('$profilePath/$fileName');
      if (!await newFile.exists()) {
        await file.copy(newFile.path);
      }
    }

    return profilePath;
  }

  Future<void> _pickTextFolder() async {
    final result = await getDirectoryPath();
    if (result != null) {
      setState(() {
        _selectedTextFolder = result;
      });
    }
  }

  Future<void> _pickMediaFolder() async {
    final result = await getDirectoryPath();
    if (result != null) {
      setState(() {
        _selectedMediaFolder = result;
      });
    }
  }

  void _saveProfile() async {
    final name = _nameController.text.trim();
    final text = _selectedTextFolder;
    final media = _selectedMediaFolder;
    final conn = _selectedConnection;

    if (name.isEmpty || text == null || media == null || conn == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Molimo popunite sve podatke.')),
      );
      return;
    }

    final lyricsPath = await _copyFolderToProfile(text, name, 'txt', '.txt');
    final attachmentsPath = await _copyFolderToProfile(media, name, 'attachments', '');

    final appDir = await getApplicationDocumentsDirectory();
    final profileDir = Directory('${appDir.path}/profiles/$name');
    final settingsFile = File('${profileDir.path}/settings.json');
    if (!await settingsFile.exists()) {
      await settingsFile.writeAsString('{}');
    }

    await ProfileController.saveProfile(
      name: name,
      lyricsPath: lyricsPath ?? '',
      mediaPath: attachmentsPath ?? '',
      connection: conn,
    );

    await _loadProfiles();

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Profil spremljen.')),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Postavljanje profila')),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('Ime profila (max 7 znakova):'),
              TextField(
                controller: _nameController,
                maxLength: 7,
                decoration: const InputDecoration(hintText: 'Unesi ime'),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: _pickTextFolder,
                child: Text(_selectedTextFolder ?? 'Odaberi mapu s tekstovima'),
              ),
              const SizedBox(height: 12),
              ElevatedButton(
                onPressed: _pickMediaFolder,
                child: Text(_selectedMediaFolder ?? 'Odaberi prateÄ‡u mapu'),
              ),
              const SizedBox(height: 20),
              const Text('Odaberi vezu:'),
              DropdownButton<String>(
                isExpanded: true,
                hint: const Text('Veza'),
                value: _selectedConnection,
                items: const [
                  DropdownMenuItem(value: 'WiFi', child: Text('WiFi')),
                  DropdownMenuItem(value: 'Hotspot', child: Text('Hotspot')),
                  DropdownMenuItem(value: 'Bluetooth', child: Text('Bluetooth')),
                  DropdownMenuItem(value: 'Nema', child: Text('Bez veze')),
                ],
                onChanged: (value) {
                  setState(() {
                    _selectedConnection = value;
                  });
                },
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: _saveProfile,
                child: const Text('SPREMI PROFIL'),
              ),
              const Divider(height: 40),
              const Text('Dostupni profili:'),
              for (var p in _profiles)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4.0),
                  child: ElevatedButton(
                    onPressed: () async {
                      final name = p['name'];
                      await ActiveProfileController.setActiveProfile(name);

                      final appDir = await getApplicationDocumentsDirectory();
                      final profilePath = '${appDir.path}/profiles/$name';
                      final txtDir = Directory('$profilePath/txt');
                      final attachmentsDir = Directory('$profilePath/attachments');
                      final settingsFile = File('$profilePath/settings.json');

                      if (!await txtDir.exists()) await txtDir.create(recursive: true);
                      if (!await attachmentsDir.exists()) await attachmentsDir.create(recursive: true);
                      if (!await settingsFile.exists()) {
                        await settingsFile.writeAsString('{}');
                      }

                      setState(() {
                        _selectedProfile = p;
                      });
                    },
                    child: Text(p['name']),
                  ),
                ),
              const SizedBox(height: 20),
              if (_selectedProfile != null)
                ElevatedButton(
                  onPressed: () {
                    context.go('/song-view');
                  },
                  child: const Text('ULAZ'),
                ),
              const SizedBox(height: 40),
              Center(
                child: IconButton(
                  icon: const Icon(Icons.arrow_back),
                  iconSize: 48,
                  onPressed: () {
                    context.go('/language');
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/services/profile_storage_servicedart ===
import 'dart:convert';
import 'dart:io';

import 'package:path_provider/path_provider.dart';

class ProfileStorageService {
  static Future<String> _getProfilesFilePath() async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/profiles.json');
    return file.path;
  }

  static Future<void> saveProfile({
    required String name,
    required String lyricsPath,
    required String attachmentsPath,
  }) async {
    final path = await _getProfilesFilePath();
    final file = File(path);

    Map<String, dynamic> profileData = {
      'name': name,
      'lyricsPath': lyricsPath,
      'attachmentsPath': attachmentsPath,
    };

    List<Map<String, dynamic>> profiles = [];

    if (await file.exists()) {
      final content = await file.readAsString();
      profiles = List<Map<String, dynamic>>.from(json.decode(content));
    }

    profiles.removeWhere((p) => p['name'] == name);
    profiles.add(profileData);

    await file.writeAsString(json.encode(profiles));
  }

  static Future<List<Map<String, dynamic>>> loadProfiles() async {
    final path = await _getProfilesFilePath();
    final file = File(path);

    if (!await file.exists()) return [];

    final content = await file.readAsString();
    final profiles = List<Map<String, dynamic>>.from(json.decode(content));
    return profiles;
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/utils/file_copy_servicedart ===
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

class FileCopyService {
  /// Kopira sve .txt fajlove iz [sourcePath] u internu memoriju aplikacije
  /// na lokaciju: appDocDir/txt/
  static Future<void> copyTxtFilesToInternal(String sourcePath) async {
    final sourceDir = Directory(sourcePath);
    if (!await sourceDir.exists()) return;

    final appDir = await getApplicationDocumentsDirectory();
    final targetDir = Directory(p.join(appDir.path, 'txt'));

    if (!await targetDir.exists()) {
      await targetDir.create(recursive: true);
    }

    final txtFiles = sourceDir
        .listSync()
        .whereType<File>()
        .where((file) => file.path.toLowerCase().endsWith('.txt'));

    for (final file in txtFiles) {
      final fileName = p.basename(file.path);
      final targetFile = File(p.join(targetDir.path, fileName));
      await file.copy(targetFile.path);
    }
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/profile_setup/widgets/profile_buttonsdart ===
import 'package:flutter/material.dart';

class ProfileButtons extends StatelessWidget {
  final List<String> profiles;
  final void Function(String) onProfileSelected;

  const ProfileButtons({
    Key? key,
    required this.profiles,
    required this.onProfileSelected,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: profiles.length,
      itemBuilder: (context, index) {
        final profile = profiles[index];
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
          child: Row(
            children: [
              Expanded(
                child: ElevatedButton(
                  onPressed: () => onProfileSelected(profile),
                  child: Text(profile),
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                icon: const Icon(Icons.delete),
                onPressed: () {
                  // TODO: Dodati potvrdu i funkciju brisanja
                },
              ),
            ],
          ),
        );
      },
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_search/screens/song_search_screendart ===
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:chordsbandkompok/features/song_view/screens/song_view_screen.dart';

class SongSearchScreen extends StatefulWidget {
  const SongSearchScreen({Key? key}) : super(key: key);

  @override
  State<SongSearchScreen> createState() => _SongSearchScreenState();
}

class _SongSearchScreenState extends State<SongSearchScreen> {
  List<File> _txtFiles = [];
  List<File> _filteredFiles = [];
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadTxtFiles();
    _searchController.addListener(_onSearchChanged);
  }

  Future<void> _loadTxtFiles() async {
    final Directory appDir = await getApplicationDocumentsDirectory();
    final Directory txtDir = Directory('${appDir.path}/txt');

    if (await txtDir.exists()) {
      final allFiles = txtDir.listSync();
      final txtFiles = allFiles
          .whereType<File>()
          .where((file) => file.path.toLowerCase().endsWith('.txt'))
          .toList();

      setState(() {
        _txtFiles = txtFiles;
        _filteredFiles = txtFiles;
      });
    }
  }

  void _onSearchChanged() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredFiles = _txtFiles
          .where((file) => file.path.toLowerCase().contains(query))
          .toList();
    });
  }

  void _openSong(File file) {
    final String fileName = file.uri.pathSegments.last;
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => SongViewScreen(fileName: fileName),
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Popis pjesama'),
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                hintText: 'PretraĹľi pjesme...',
                prefixIcon: Icon(Icons.search),
                border: OutlineInputBorder(),
              ),
            ),
          ),
          Expanded(
            child: _filteredFiles.isEmpty
                ? const Center(child: Text('Nema pjesama'))
                : ListView.builder(
                    itemCount: _filteredFiles.length,
                    itemBuilder: (context, index) {
                      final file = _filteredFiles[index];
                      final fileName = file.uri.pathSegments.last;
                      return ListTile(
                        title: Text(fileName),
                        onTap: () => _openSong(file),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/controllers/song_editor_controllerdart ===
import 'dart:io';

class SongEditorController {
  static Future<void> saveEditedSong(String path, String content) async {
    final file = File(path);
    await file.writeAsString(content);
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/controllers/song_settings_controllerdart ===
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import '../../profile_setup/controllers/active_profile_controller.dart';
import '../utils/settings_sanitizer.dart';

class SongSettingsController {
  static Map<String, dynamic> _settings = {};

  static Future<File?> _getSettingsFile() async {
    final profile = await ActiveProfileController.getActiveProfileData();
    if (profile == null || profile['lyricsPath'] == null) return null;

    final settingsPath = '${profile['lyricsPath']}/../settings.json';
    final file = File(settingsPath);
    return file;
  }

  static Future<void> loadSettings() async {
    final file = await _getSettingsFile();
    if (file == null || !file.existsSync()) return;

    final content = await file.readAsString();
    _settings = jsonDecode(content);
  }

  static Future<void> saveSettings() async {
    final file = await _getSettingsFile();
    if (file == null) return;

    await file.writeAsString(jsonEncode(_settings));
  }

  static double getTextFontSize(String songName) {
    return SettingsSanitizer.sanitizeFontSize(_settings[songName]?['textFontSize']);
  }

  static double getChordFontSize(String songName) {
    return SettingsSanitizer.sanitizeFontSize(_settings[songName]?['chordFontSize']);
  }

  static void setTextFontSize(String songName, double size) {
    _settings[songName] ??= {};
    _settings[songName]['textFontSize'] = size;
    saveSettings();
  }

  static void setChordFontSize(String songName, double size) {
    _settings[songName] ??= {};
    _settings[songName]['chordFontSize'] = size;
    saveSettings();
  }

  static Color getTextColor(String songName) {
    final hex = _settings[songName]?['textColor'] ?? '#000000';
    return _colorFromHex(hex);
  }

  static Color getChordColor(String songName) {
    final hex = _settings[songName]?['chordColor'] ?? '#0000FF';
    return _colorFromHex(hex);
  }

  static void setTextColor(String songName, Color color) {
    _settings[songName] ??= {};
    _settings[songName]['textColor'] = _colorToHex(color);
    saveSettings();
  }

  static void setChordColor(String songName, Color color) {
    _settings[songName] ??= {};
    _settings[songName]['chordColor'] = _colorToHex(color);
    saveSettings();
  }

  static String? getAttachment(String songName) {
    return _settings[songName]?['attachment'];
  }

  static void setAttachment(String songName, String fileName) {
    _settings[songName] ??= {};
    _settings[songName]['attachment'] = fileName;
    saveSettings();
  }

  static int getScrollUpLines(String songName) {
    return SettingsSanitizer.sanitizeScrollLines(_settings[songName]?['scrollUp']);
  }

  static int getScrollDownLines(String songName) {
    return SettingsSanitizer.sanitizeScrollLines(_settings[songName]?['scrollDown']);
  }

  static void setScrollUpLines(String songName, int value) {
    _settings[songName] ??= {};
    _settings[songName]['scrollUp'] = value;
    saveSettings();
  }

  static void setScrollDownLines(String songName, int value) {
    _settings[songName] ??= {};
    _settings[songName]['scrollDown'] = value;
    saveSettings();
  }

  static String _colorToHex(Color color) {
    return '#${color.value.toRadixString(16).padLeft(8, '0')}';
  }

  static Color _colorFromHex(String hex) {
    hex = hex.replaceAll('#', '');
    if (hex.length == 6) hex = 'ff$hex';
    return Color(int.parse(hex, radix: 16));
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/screens/song_color_settings_screendart ===
import 'package:flutter/material.dart';
import 'package:flutter_colorpicker/flutter_colorpicker.dart';

class SongColorSettingsScreen extends StatefulWidget {
  final Color initialTextColor;
  final Color initialChordColor;

  const SongColorSettingsScreen({
    super.key,
    required this.initialTextColor,
    required this.initialChordColor,
  });

  @override
  State<SongColorSettingsScreen> createState() => _SongColorSettingsScreenState();
}

class _SongColorSettingsScreenState extends State<SongColorSettingsScreen> {
  late Color _textColor;
  late Color _chordColor;

  @override
  void initState() {
    super.initState();
    _textColor = widget.initialTextColor;
    _chordColor = widget.initialChordColor;
  }

  Future<void> _pickColor({
    required Color currentColor,
    required ValueChanged<Color> onColorSelected,
  }) async {
    final newColor = await showDialog<Color>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Odaberi boju'),
        content: SingleChildScrollView(
          child: BlockPicker(
            pickerColor: currentColor,
            onColorChanged: onColorSelected,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(currentColor),
            child: const Text('Zatvori'),
          ),
        ],
      ),
    );

    if (newColor != null) {
      onColorSelected(newColor);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Boje prikaza')),
      body: Column(
        children: [
          ListTile(
            title: const Text('Boja teksta'),
            trailing: Container(
              width: 24,
              height: 24,
              color: _textColor,
            ),
            onTap: () => _pickColor(
              currentColor: _textColor,
              onColorSelected: (color) => setState(() => _textColor = color),
            ),
          ),
          ListTile(
            title: const Text('Boja akorda'),
            trailing: Container(
              width: 24,
              height: 24,
              color: _chordColor,
            ),
            onTap: () => _pickColor(
              currentColor: _chordColor,
              onColorSelected: (color) => setState(() => _chordColor = color),
            ),
          ),
          const Spacer(),
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              onPressed: () {
                Navigator.of(context).pop({
                  'textColor': _textColor,
                  'chordColor': _chordColor,
                });
              },
              child: const Text('Spremi'),
            ),
          )
        ],
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/screens/song_edit_screendart ===
import 'package:flutter/material.dart';
import 'dart:io';
import '../controllers/song_editor_controller.dart';

class SongEditScreen extends StatefulWidget {
  final String filePath;

  const SongEditScreen({super.key, required this.filePath});

  @override
  State<SongEditScreen> createState() => _SongEditScreenState();
}

class _SongEditScreenState extends State<SongEditScreen> {
  final TextEditingController _controller = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadFile();
  }

  Future<void> _loadFile() async {
    final file = File(widget.filePath);
    if (await file.exists()) {
      _controller.text = await file.readAsString();
    }
    setState(() {});
  }

  Future<void> _save() async {
    await SongEditorController.saveEditedSong(widget.filePath, _controller.text);
    if (mounted) Navigator.pop(context, true);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Uredi tekst'),
        actions: [
          IconButton(icon: const Icon(Icons.save), onPressed: _save),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(12.0),
        child: TextField(
          controller: _controller,
          maxLines: null,
          decoration: const InputDecoration(border: OutlineInputBorder()),
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/screens/song_search_screendart ===
import "dart:io";
import "package:flutter/material.dart";
import "package:go_router/go_router.dart";
import "../../profile_setup/controllers/current_profile_loader.dart";
import "../utils/setlist_manager.dart";
import "../widgets/setlist_controls_widget.dart";

class SongSearchScreen extends StatefulWidget {
  const SongSearchScreen({super.key});

  @override
  State<SongSearchScreen> createState() => _SongSearchScreenState();
}

class _SongSearchScreenState extends State<SongSearchScreen> {
  List<String> allSongs = [];
  List<String> filteredSongs = [];
  String searchQuery = "";
  String? activeSetlistName;

  @override
  void initState() {
    super.initState();
    _loadSongs();
  }

  Future<void> _loadSongs() async {
    final profile = await CurrentProfileLoader.loadLastProfile();
    final folderPath = profile?['text_folder'];

    if (folderPath == null) return;

    final folder = Directory(folderPath);
    if (!folder.existsSync()) return;

    final txtFiles = folder
        .listSync()
        .whereType<File>()
        .where((file) => file.path.toLowerCase().endsWith(".txt"))
        .map((file) => file.uri.pathSegments.last)
        .toList();

    setState(() {
      allSongs = txtFiles;
      filteredSongs = txtFiles;
    });
  }

  void _filterSongs(String query) {
    setState(() {
      searchQuery = query;
      filteredSongs = allSongs
          .where((song) => song.toLowerCase().contains(query.toLowerCase()))
          .toList();
    });
  }

  void _setActiveSetlist(String name) {
    setState(() {
      activeSetlistName = name;
    });
  }

  void _addToSetlist(String song) {
    if (activeSetlistName == null) return;
    SetlistManager.addSong(song, activeSetlistName!);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Pretraga pjesama")),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: TextField(
              onChanged: _filterSongs,
              decoration: const InputDecoration(
                labelText: "Pretraži...",
                border: OutlineInputBorder(),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12.0),
            child: SetlistControlsWidget(
              onSetlistCreated: _setActiveSetlist,
            ),
          ),
          if (activeSetlistName != null)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Text("Aktivna lista: $activeSetlistName"),
            ),
          const SizedBox(height: 8),
          Expanded(
            child: ListView.builder(
              itemCount: filteredSongs.length,
              itemBuilder: (context, index) {
                final song = filteredSongs[index];
                return ListTile(
                  title: Text(song),
                  onTap: () {
                    context.go("/song-view?file=$song");
                  },
                  trailing: IconButton(
                    icon: const Icon(Icons.playlist_add),
                    onPressed: () {
                      _addToSetlist(song);
                    },
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/screens/song_settings_screendart ===
import 'package:flutter/material.dart';

class SongSettingsScreen extends StatefulWidget {
  final double textFontSize;
  final double chordFontSize;
  final Color textColor;
  final Color chordColor;
  final int scrollUp;
  final int scrollDown;

  const SongSettingsScreen({
    super.key,
    required this.textFontSize,
    required this.chordFontSize,
    required this.textColor,
    required this.chordColor,
    required this.scrollUp,
    required this.scrollDown,
  });

  @override
  State<SongSettingsScreen> createState() => _SongSettingsScreenState();
}

class _SongSettingsScreenState extends State<SongSettingsScreen> {
  late double _textFontSize;
  late double _chordFontSize;
  late Color _textColor;
  late Color _chordColor;
  late int _scrollUp;
  late int _scrollDown;

  final List<Color> _colors = [
    Colors.black,
    Colors.red,
    Colors.blue,
    Colors.green,
    Colors.orange,
    Colors.purple,
    Colors.teal,
    Colors.brown,
  ];

  @override
  void initState() {
    super.initState();
    _textFontSize = widget.textFontSize;
    _chordFontSize = widget.chordFontSize;
    _textColor = widget.textColor;
    _chordColor = widget.chordColor;
    _scrollUp = widget.scrollUp;
    _scrollDown = widget.scrollDown;
  }

  Widget _buildColorPicker(String label, Color selectedColor, ValueChanged<Color> onColorSelected) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: _colors.map((color) {
            return GestureDetector(
              onTap: () => setState(() => onColorSelected(color)),
              child: CircleAvatar(
                backgroundColor: color,
                radius: 16,
                child: selectedColor == color ? const Icon(Icons.check, color: Colors.white, size: 16) : null,
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Postavke prikaza')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Veličina teksta'),
            Slider(
              value: _textFontSize,
              min: 10,
              max: 40,
              divisions: 15,
              label: _textFontSize.toStringAsFixed(0),
              onChanged: (value) => setState(() => _textFontSize = value),
            ),
            const SizedBox(height: 16),
            const Text('Veličina akorda'),
            Slider(
              value: _chordFontSize,
              min: 10,
              max: 40,
              divisions: 15,
              label: _chordFontSize.toStringAsFixed(0),
              onChanged: (value) => setState(() => _chordFontSize = value),
            ),
            const SizedBox(height: 24),
            _buildColorPicker('Boja teksta', _textColor, (color) => _textColor = color),
            const SizedBox(height: 16),
            _buildColorPicker('Boja akorda', _chordColor, (color) => _chordColor = color),
            const SizedBox(height: 24),
            const Text('Redova po scroll UP'),
            Slider(
              value: _scrollUp.toDouble(),
              min: 1,
              max: 15,
              divisions: 14,
              label: _scrollUp.toString(),
              onChanged: (value) => setState(() => _scrollUp = value.toInt()),
            ),
            const SizedBox(height: 16),
            const Text('Redova po scroll DOWN'),
            Slider(
              value: _scrollDown.toDouble(),
              min: 1,
              max: 15,
              divisions: 14,
              label: _scrollDown.toString(),
              onChanged: (value) => setState(() => _scrollDown = value.toInt()),
            ),
            const Spacer(),
            Center(
              child: ElevatedButton(
                onPressed: () {
                  Navigator.pop(context, {
                    'textFontSize': _textFontSize,
                    'chordFontSize': _chordFontSize,
                    'textColor': _textColor,
                    'chordColor': _chordColor,
                    'scrollUp': _scrollUp,
                    'scrollDown': _scrollDown,
                  });
                },
                child: const Text('Spremi'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/screens/song_view_screendart ===
import "package:flutter/material.dart";
import "dart:io";
import "package:path_provider/path_provider.dart";
import "../widgets/song_controls_widget.dart";
import "../utils/transpose_helper.dart";
import "../utils/rich_song_parser.dart";
import "../controllers/song_settings_controller.dart";
import '../widgets/scroll_control_widget.dart';
import '../../profile_setup/controllers/active_profile_controller.dart';
import '../widgets/attachment_button.dart'; // â† potrebno jer viĹˇe nije u controls

class SongViewScreen extends StatefulWidget {
  const SongViewScreen({super.key});

  @override
  State<SongViewScreen> createState() => _SongViewScreenState();
}

class _SongViewScreenState extends State<SongViewScreen> {
  List<File> _allSongs = [];
  int _currentIndex = 0;
  List<String> _songLines = [];
  String? _songName;
  File? _currentFile;
  int _transposeSteps = 0;

  double _textFontSize = 18;
  double _chordFontSize = 20;
  Color _textColor = Colors.black;
  Color _chordColor = Colors.blue;

  int _scrollUpLines = 3;
  int _scrollDownLines = 5;

  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    SongSettingsController.loadSettings().then((_) {
      _loadSongsFromProfile();
    });
  }

  Future<void> _loadSongsFromProfile() async {
    final profile = await ActiveProfileController.getActiveProfileData();
    if (profile == null || profile['lyricsPath'] == null) return;

    final dir = Directory(profile['lyricsPath']);
    if (!dir.existsSync()) return;

    final files = dir
        .listSync()
        .whereType<File>()
        .where((f) => f.path.toLowerCase().endsWith('.txt'))
        .toList();

    if (files.isEmpty) return;

    setState(() {
      _allSongs = files;
      _currentIndex = 0;
    });

    _loadSongAt(_currentIndex);
  }

  Future<void> _loadSongAt(int index) async {
    if (index < 0 || index >= _allSongs.length) return;

    final file = _allSongs[index];
    final lines = await file.readAsLines();
    final name = file.uri.pathSegments.last;

    setState(() {
      _songLines = lines;
      _songName = name;
      _currentFile = file;
      _transposeSteps = 0;
      _loadSettingsForSong();
    });
  }

  void _loadSettingsForSong() {
    if (_songName == null) return;
    setState(() {
      _textFontSize = SongSettingsController.getTextFontSize(_songName!);
      _chordFontSize = SongSettingsController.getChordFontSize(_songName!);
      _textColor = SongSettingsController.getTextColor(_songName!);
      _chordColor = SongSettingsController.getChordColor(_songName!);
      _scrollUpLines = SongSettingsController.getScrollUpLines(_songName!);
      _scrollDownLines = SongSettingsController.getScrollDownLines(_songName!);
    });
  }

  void _transposeUp() => setState(() => _transposeSteps++);
  void _transposeDown() => setState(() => _transposeSteps--);

  void _zoomIn() {
    if (_songName == null) return;
    setState(() {
      _textFontSize += 1;
      SongSettingsController.setTextFontSize(_songName!, _textFontSize);
    });
  }

  void _zoomOut() {
    if (_songName == null) return;
    setState(() {
      _textFontSize -= 1;
      if (_textFontSize < 10) _textFontSize = 10;
      SongSettingsController.setTextFontSize(_songName!, _textFontSize);
    });
  }

  void _onSettingsChanged() {
    _loadSettingsForSong();
  }

  void _refreshCurrentSong() {
    _loadSongAt(_currentIndex);
  }

  void _nextSong() {
    if (_currentIndex < _allSongs.length - 1) {
      _currentIndex++;
      _loadSongAt(_currentIndex);
    }
  }

  void _previousSong() {
    if (_currentIndex > 0) {
      _currentIndex--;
      _loadSongAt(_currentIndex);
    }
  }

  void _scrollUp() {
    final offset = (_scrollUpLines * 20).toDouble();
    _scrollController.animateTo(
      _scrollController.offset - offset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  void _scrollDown() {
    final offset = (_scrollDownLines * 20).toDouble();
    _scrollController.animateTo(
      _scrollController.offset + offset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  Widget build(BuildContext context) {
    final fullText = _songLines.join('\n');
    final transposedText = fullText.split('\n').map((line) {
      return TransposeHelper.transpose(line, _transposeSteps);
    }).join('\n');

    final spans = RichSongParser.parseSong(
      transposedText,
      textFontSize: _textFontSize,
      chordFontSize: _chordFontSize,
      textColor: _textColor,
      chordColor: _chordColor,
    );

    return Scaffold(
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                SongControlsWidget(
                  onTransposeUp: _transposeUp,
                  onTransposeDown: _transposeDown,
                  onZoomIn: _zoomIn,
                  onZoomOut: _zoomOut,
                  songName: _songName,
                  filePath: _currentFile?.path,
                  onSettingsChanged: _onSettingsChanged,
                  onSongEdited: _refreshCurrentSong,
                ),
                const Divider(),
                Padding(
                  padding: const EdgeInsets.only(top: 8, left: 16, right: 16),
                  child: Row(
                    children: [
                      IconButton(icon: const Icon(Icons.arrow_back), onPressed: _previousSong),
                      const Spacer(),
                      IconButton(icon: const Icon(Icons.arrow_forward), onPressed: _nextSong),
                      const SizedBox(width: 8),
                      AttachmentButton(songName: _songName),
                    ],
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4),
                  child: Text(
                    _songName ?? 'Pjesma',
                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    textAlign: TextAlign.center,
                  ),
                ),
                Expanded(
                  child: _songLines.isEmpty
                      ? const Center(child: Text('Nema dostupnih pjesama.'))
                      : Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: SingleChildScrollView(
                            controller: _scrollController,
                            child: RichText(text: TextSpan(children: spans)),
                          ),
                        ),
                ),
              ],
            ),
            ScrollControlWidget(
              onScrollUp: _scrollUp,
              onScrollDown: _scrollDown,
            ),
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/utils/rich_song_parserdart ===
import "package:flutter/material.dart";

class RichSongParser {
  static List<TextSpan> parseSong(
    String text, {
    double textFontSize = 18,
    double chordFontSize = 20,
    Color textColor = Colors.black,
    Color chordColor = Colors.blue,
  }) {
    final regex = RegExp(r'(\(.*?\))');
    final spans = <TextSpan>[];

    text.split('\n').forEach((line) {
      final matches = regex.allMatches(line);
      int lastMatchEnd = 0;

      for (final match in matches) {
        if (match.start > lastMatchEnd) {
          spans.add(TextSpan(
            text: line.substring(lastMatchEnd, match.start),
            style: TextStyle(
              fontSize: textFontSize,
              color: textColor,
            ),
          ));
        }

        spans.add(TextSpan(
          text: match.group(0),
          style: TextStyle(
            fontSize: chordFontSize,
            color: chordColor,
            fontWeight: FontWeight.bold,
          ),
        ));

        lastMatchEnd = match.end;
      }

      if (lastMatchEnd < line.length) {
        spans.add(TextSpan(
          text: line.substring(lastMatchEnd),
          style: TextStyle(
            fontSize: textFontSize,
            color: textColor,
          ),
        ));
      }

      spans.add(const TextSpan(text: '\n'));
    });

    return spans;
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/utils/setlist_managerdart ===
import "dart:convert";
import "dart:io";
import "../../profile_setup/controllers/active_profile_controller.dart";

class SetlistManager {
  static Future<void> addSong(String songName, String setlistName) async {
    final profile = await ActiveProfileController.getActiveProfileData();
    final basePath = profile?['lyricsPath'];
    if (basePath == null) return;

    final folder = Directory("$basePath/setlists");
    if (!folder.existsSync()) folder.createSync(recursive: true);

    final file = File("${folder.path}/$setlistName.json");

    List<String> songs = [];
    if (file.existsSync()) {
      final content = file.readAsStringSync();
      songs = List<String>.from(jsonDecode(content));
    }

    if (!songs.contains(songName)) {
      songs.add(songName);
      file.writeAsStringSync(jsonEncode(songs));
    }
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/utils/settings_sanitizerdart ===
class SettingsSanitizer {
  static double sanitizeFontSize(dynamic value) {
    if (value is num && value >= 10 && value <= 50) {
      return value.toDouble();
    }
    return 18.0;
  }

  static int sanitizeScrollLines(dynamic value) {
    if (value is int && value >= 1 && value <= 30) {
      return value;
    }
    return 3;
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/utils/song_loaderdart ===
import 'dart:io';
import 'package:path_provider/path_provider.dart';

class SongLoader {
  static Future<List<String>> loadSongs() async {
    final dir = await getApplicationDocumentsDirectory();
    final txtDir = Directory('${dir.path}/txt');

    if (!await txtDir.exists()) return [];

    final files = txtDir
        .listSync()
        .whereType<File>()
        .where((f) => f.path.toLowerCase().endsWith('.txt'))
        .toList();

    files.sort((a, b) => a.path.compareTo(b.path));

    return files.map((f) => f.path).toList();
  }

  static Future<String> loadSongContent(String path) async {
    final file = File(path);
    return await file.readAsString();
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/utils/transpose_helperdart ===
class TransposeHelper {
  static final List<String> _notes = [
    'C', 'C#', 'D', 'D#', 'E', 'F',
    'F#', 'G', 'G#', 'A', 'A#', 'B'
  ];

  static String transpose(String line, int steps) {
    final regex = RegExp(r'\(([A-G][#b]?[^)]*)\)');
    return line.replaceAllMapped(regex, (match) {
      final full = match.group(0)!;
      final chord = match.group(1)!;
      final transposed = _transposeChord(chord, steps);
      return '($transposed)';
    });
  }

  static String _transposeChord(String chord, int steps) {
    for (final note in _notes) {
      if (chord.startsWith(note)) {
        final index = _notes.indexOf(note);
        final newIndex = (index + steps) % 12;
        final transposedNote = _notes[newIndex < 0 ? newIndex + 12 : newIndex];
        return transposedNote + chord.substring(note.length);
      }
    }
    return chord;
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/attachment_buttondart ===
import "dart:io";
import "package:flutter/material.dart";
import "package:open_file/open_file.dart";
import "../../profile_setup/controllers/active_profile_controller.dart";
import "../controllers/song_settings_controller.dart";

class AttachmentButton extends StatefulWidget {
  final String? songName;

  const AttachmentButton({super.key, this.songName});

  @override
  State<AttachmentButton> createState() => _AttachmentButtonState();
}

class _AttachmentButtonState extends State<AttachmentButton> {
  String? currentFile;

  @override
  void initState() {
    super.initState();
    _refreshFile();
  }

  @override
  void didUpdateWidget(covariant AttachmentButton oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.songName != widget.songName) {
      _refreshFile();
    }
  }

  void _refreshFile() {
    if (widget.songName != null) {
      setState(() {
        currentFile = SongSettingsController.getAttachment(widget.songName!);
      });
    }
  }

  Future<void> _onPressed() async {
    if (widget.songName == null) return;

    final profile = await ActiveProfileController.getActiveProfileData();
    if (profile == null || profile['mediaPath'] == null) return;

    final dir = Directory(profile['mediaPath']);
    if (!dir.existsSync()) return;

    if (currentFile != null) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => SimpleDialog(
          title: const Text("PrateÄ‡i fajl"),
          children: [
            SimpleDialogOption(
              child: const Text("Otvori fajl"),
              onPressed: () => Navigator.pop(ctx, "open"),
            ),
            SimpleDialogOption(
              child: const Text("Promijeni fajl"),
              onPressed: () => Navigator.pop(ctx, "change"),
            ),
          ],
        ),
      );

      if (choice == "open") {
        final fullPath = "${dir.path}${Platform.pathSeparator}$currentFile";
        if (await File(fullPath).exists()) {
          OpenFile.open(fullPath);
        }
        return;
      }

      if (choice != "change") return;
    }

    final files = dir
        .listSync()
        .whereType<File>()
        .map((f) => f.path.split(Platform.pathSeparator).last)
        .toList();

    if (files.isEmpty) return;

    final selected = await showDialog<String>(
      context: context,
      builder: (ctx) => SimpleDialog(
        title: const Text("Odaberi prateÄ‡i fajl"),
        children: files.map((file) {
          return SimpleDialogOption(
            child: Text(file),
            onPressed: () => Navigator.pop(ctx, file),
          );
        }).toList(),
      ),
    );

    if (selected != null) {
      SongSettingsController.setAttachment(widget.songName!, selected);
      _refreshFile();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.end,
      children: [
        IconButton(
          icon: const Icon(Icons.attach_file),
          onPressed: _onPressed,
        ),
        if (currentFile != null)
          Padding(
            padding: const EdgeInsets.only(right: 4.0),
            child: Text(
              currentFile!,
              style: const TextStyle(fontSize: 12, color: Colors.grey),
              overflow: TextOverflow.ellipsis,
            ),
          ),
      ],
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/scroll_buttonsdart ===
import 'package:flutter/material.dart';

class ScrollButtons extends StatelessWidget {
  final VoidCallback onScrollUp;
  final VoidCallback onScrollDown;

  const ScrollButtons({
    super.key,
    required this.onScrollUp,
    required this.onScrollDown,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          icon: const Icon(Icons.keyboard_arrow_up),
          iconSize: 36,
          onPressed: onScrollUp,
        ),
        const SizedBox(height: 8),
        IconButton(
          icon: const Icon(Icons.keyboard_arrow_down),
          iconSize: 36,
          onPressed: onScrollDown,
        ),
      ],
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/scroll_control_widgetdart ===
import 'package:flutter/material.dart';

class ScrollControlWidget extends StatelessWidget {
  final VoidCallback onScrollUp;
  final VoidCallback onScrollDown;

  const ScrollControlWidget({
    super.key,
    required this.onScrollUp,
    required this.onScrollDown,
  });

  @override
  Widget build(BuildContext context) {
    return Positioned(
      right: 4,
      bottom: 40,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: const Icon(Icons.arrow_upward),
            iconSize: 32,
            onPressed: onScrollUp,
          ),
          const SizedBox(height: 8),
          IconButton(
            icon: const Icon(Icons.arrow_downward),
            iconSize: 32,
            onPressed: onScrollDown,
          ),
        ],
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/setlist_controls_widgetdart ===
import "dart:convert";
import "dart:io";
import "package:flutter/material.dart";
import "../../profile_setup/controllers/current_profile_loader.dart";

class SetlistControlsWidget extends StatefulWidget {
  final void Function(String)? onSetlistCreated;

  const SetlistControlsWidget({super.key, this.onSetlistCreated});

  @override
  State<SetlistControlsWidget> createState() => _SetlistControlsWidgetState();
}

class _SetlistControlsWidgetState extends State<SetlistControlsWidget> {
  final TextEditingController _controller = TextEditingController();
  String? activeSetlistName;

  void _createSetlist() async {
    final name = _controller.text.trim();
    if (name.isEmpty) return;

    final profile = await CurrentProfileLoader.loadLastProfile();
    final folder = Directory("${profile?['text_folder']}\\setlists");
    if (!folder.existsSync()) folder.createSync(recursive: true);

    final file = File("${folder.path}\\$name.json");
    if (!file.existsSync()) {
      file.writeAsStringSync(jsonEncode([]));
    }

    setState(() {
      activeSetlistName = name;
    });

    if (widget.onSetlistCreated != null) {
      widget.onSetlistCreated!(name);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                decoration: const InputDecoration(
                  hintText: "Unesi ime nove set liste",
                ),
              ),
            ),
            ElevatedButton(
              onPressed: _createSetlist,
              child: const Text("Kreiraj"),
            ),
          ],
        ),
        if (activeSetlistName != null)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Text("Aktivna set lista: $activeSetlistName"),
          ),
      ],
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/song_controls_widgetdart ===
import "package:flutter/material.dart";
import "package:go_router/go_router.dart";
import "../screens/song_settings_screen.dart";
import "../controllers/song_settings_controller.dart";
import "../screens/song_edit_screen.dart";
import "attachment_button.dart";

class SongControlsWidget extends StatelessWidget {
  final VoidCallback? onTransposeUp;
  final VoidCallback? onTransposeDown;
  final VoidCallback? onZoomIn;
  final VoidCallback? onZoomOut;
  final String? songName;
  final String? filePath;
  final void Function()? onSettingsChanged;
  final void Function()? onSongEdited;

  const SongControlsWidget({
    super.key,
    this.onTransposeUp,
    this.onTransposeDown,
    this.onZoomIn,
    this.onZoomOut,
    this.songName,
    this.filePath,
    this.onSettingsChanged,
    this.onSongEdited,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4),
        child: Row(
          children: [
            IconButton(
              icon: const Icon(Icons.search),
              onPressed: () {
                context.go('/song-search');
              },
            ),
            IconButton(icon: const Icon(Icons.remove), onPressed: onTransposeDown),
            IconButton(icon: const Icon(Icons.add), onPressed: onTransposeUp),
            IconButton(icon: const Icon(Icons.lock), onPressed: () {}),
            ElevatedButton(onPressed: () {}, child: const Text("OUT")),
            IconButton(icon: const Icon(Icons.zoom_out), onPressed: onZoomOut),
            IconButton(icon: const Icon(Icons.zoom_in), onPressed: onZoomIn),
            IconButton(
              icon: const Icon(Icons.edit),
              onPressed: () async {
                if (filePath == null) return;
                final result = await Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => SongEditScreen(filePath: filePath!),
                  ),
                );
                if (result == true && onSongEdited != null) {
                  onSongEdited!();
                }
              },
            ),
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () async {
                if (songName == null) return;

                final currentTextSize = SongSettingsController.getTextFontSize(songName!);
                final currentChordSize = SongSettingsController.getChordFontSize(songName!);
                final currentTextColor = SongSettingsController.getTextColor(songName!);
                final currentChordColor = SongSettingsController.getChordColor(songName!);
                final currentScrollUp = SongSettingsController.getScrollUpLines(songName!);
                final currentScrollDown = SongSettingsController.getScrollDownLines(songName!);

                final result = await Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => SongSettingsScreen(
                      textFontSize: currentTextSize,
                      chordFontSize: currentChordSize,
                      textColor: currentTextColor,
                      chordColor: currentChordColor,
                      scrollUp: currentScrollUp,
                      scrollDown: currentScrollDown,
                    ),
                  ),
                );

                if (result != null && result is Map) {
                  SongSettingsController.setTextFontSize(songName!, result['textFontSize']);
                  SongSettingsController.setChordFontSize(songName!, result['chordFontSize']);
                  SongSettingsController.setTextColor(songName!, result['textColor']);
                  SongSettingsController.setChordColor(songName!, result['chordColor']);
                  if (result.containsKey('scrollUp')) {
                    SongSettingsController.setScrollUpLines(songName!, result['scrollUp']);
                  }
                  if (result.containsKey('scrollDown')) {
                    SongSettingsController.setScrollDownLines(songName!, result['scrollDown']);
                  }
                  if (onSettingsChanged != null) onSettingsChanged!();
                }
              },
            ),
          ],
        ),
      ),
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/song_text_containerdart ===
import 'package:flutter/material.dart';
import 'package:chordsbandkompok/features/song_view/widgets/attachment_button.dart';

class SongTextContainer extends StatelessWidget {
  final String songText;
  final String songFilename;

  const SongTextContainer({
    Key? key,
    required this.songText,
    required this.songFilename,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          child: SelectableText(songText),
        ),
        Positioned(
          top: 8,
          right: 8,
          child: AttachmentButton(songName: songFilename),
        ),
      ],
    );
  }
}



=== C:/Users/Korisnik/Documents/projekti/chordsbandkompok/lib/features/song_view/widgets/song_view_bodydart ===
import 'package:flutter/material.dart';
import '../../internal_file/utils/song_loader.dart';
import '../widgets/song_text_container.dart';

class SongViewBody extends StatefulWidget {
  final String filePath;

  const SongViewBody({super.key, required this.filePath});

  @override
  State<SongViewBody> createState() => _SongViewBodyState();
}

class _SongViewBodyState extends State<SongViewBody> {
  String _songText = '';
  String _filename = '';

  @override
  void initState() {
    super.initState();
    _loadSong();
  }

  Future<void> _loadSong() async {
    final content = await SongLoader.loadFromInternalPath(widget.filePath);
    setState(() {
      _songText = content;
      _filename = widget.filePath.split('/').last;
    });
    debugPrint('[SONG] UÄŤitana pjesma: $_filename');
  }

  @override
  Widget build(BuildContext context) {
    return SongTextContainer(songText: _songText, songFilename: _filename);
  }
}



